- We can, once the steps are complete, inform the user
- about the ability to change the location of the `fonts` directory
- if not satisfied, after which they run the cli command again to update
- the font file import paths

- After lofo has successfully completed its tasks, it prompts the user
- to follow the displayed link(to to the Next.js docs on fonts optimization) for
- next steps(in case they're somehow not aware of how to use the font variable or className props)

- Add ability for user to pass an argument along with `lofo` command
- for the path to their preferred final destination of the fonts directory.
- By default it'd be placed in the "public" folder of your Next.js project
- it'd create one if it doesn't already exist

- Could implement a rename step that normalizes the name of font files ensuring a consistent naming pattern
- this could be achieved by checking for the font weight(t'is the win condition)
- after which we check the elements that come before and after the weight, then discard the old string
- and create a new one that follows our opinion/standard

- QOL(Quality of Life improvemtns)
- add ability to run lofo CLI from whatever "depth" in your project directory tree



- GOALS TODAY
- IMPLEMENT UTILITY FUNCTION FOR WRITING FONTS TO FILE[ABLE TO INSERT CONTENT AT SPECIFIC POINTS]
- START IMPLEMENTING INCREMENTAL UPDATES[ON ANY SUCCESSIVE ATTEMPT TO ADD A FONT, APPEND THE RIGHT CONTENT TO INDEX FILE]
- PROPERLY IMPLEMENT MOVING FONTS DIR INTO PUBLIC DIR[ACCOMODATING OF POTENTIAL DEST ARGS PASSED BY USER]
- writeLine(filePath: string, condition: (lineNumber, lineContent, prevLineContent) => void, content: string, flag: "M")
- fileContent.split("\n").join().split("export").filter((item) => item.includes("<key>"))


- when about to write font, check if font belongs to any of the famillies that already exist
- if true, in index.ts(where fonts are being exported) modify that families src property
- if src property is type string, create a new array and spread


- STEPS TO IMPLEMENT REGROUPING
- MODIFY `getFontFiles()` to return an array of font file paths
- In `getFontFiles()`, if new font files are found, check if they belong an existing family
- if true, get the paths to their already existing families and return an array of all the files in that family plus the newly added ones
- then regroup[the regrouping step in this algo is temp, might change in the future for perf reasons??] the font families

- AFTER REGROUPING
- when writing to font, compare and identify the fonts that have changed(tokens, keys) in `index.ts` 
- and overwrite them with the new fonts
- first split file content into chunks using a user-specified separator...
- then with the user-specified key, find the chunk, whose content should be overwritten with the new content

- Add recovery step for the scenario that it passes the grouping step but fails before reaching the writing step


- GOALS TODAY
- Implement adding dynamic keys[should come from the actual files being modified] for `reWriteFileSync` -- It should probably be an array
- that takes all the possible nodes that should be overwritten
- For the code-gen step, an array should probably be return from the function(since the file has a fairly predictable structure -- 
- (import - named exports - default export))

- user can:
    - add a new font family + add a new font file
    - add a new font family
    - add a new font file

- When generating code snippet for font exports, also return file chunks along with the content to be written to file.
- The file chunks returned from `generateFileContent` are diff'd against the file chunks gotten in `reWriteFileSync`
- and this is used to figure out exactly what chunk should be overwritten. This implementation might only work if the content/chunks from both functions
- are isomorphic(almost identical) so `reWriteFilySync` should probably throw if contents are determined to not match.
- At this moment this is not viable as there's an extra step of formatting the file that the user has to do, which would most likely alter the "shape" 
- of the file -- fragile and subjective.

- New API Proposal: reWriteFileSync(filePath: string, content: string, separator: string = "\n", flag: string = "p") 
- This would work by using the value gotten from separator to
- figure out how to chunk the content of `filePath` and the `content` arg, it would then move on to compare the incoming and existing 
- chunks(strictly -- this might lead to redundant rewrites) and for the comparison to work right(regardless of variable styles of formatting) 
- it'd have to "normalize"(make each chunk one long string removing all escapes) the chunks[incoming and existing] to be compared before comparison.
- For comparison to work the chunks need to have a percentage of "similarity". If comparison yields "true" and they match, 
- the incoming chunk is favored and the existing chunk is overwritten with the new one, otherwise the exsiting chunk is preserved...
- when flag is set to `p`(pop), it overwrites the last chunk with the incoming chunk(no questions asked)
- when flag is `i*` or `i+`(insert) it would either insert incoming chunk at the end of file if there was no match or discard the chunk if there was no match
- token based comparison(??), cell size based/substring based comparison(too restrictive)



- MOVING FONTS DIR TO FINAL DESTINATION
- moving "fonts" dir into final destination would be handled by a user provided path argument when running "lofo": `lofo --final-dest <path>` or `lofo -f <path>`
- the "alternative" would be manually moving the "fonts" directory to preferred final destination and then running the "lofo" command again
- or running the command: `lofo --move <path>` or `lofo -m <path>`